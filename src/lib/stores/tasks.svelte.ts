import { LocalStore } from "./localStore.svelte";

export type Task = {
    id: string;
    title: string;
    description?: string;
    project: string;
    priority: "low" | "medium" | "high";
    status: "pending" | "in_progress" | "completed";
    link: string | null; // Optional external link
    deadline: string | null; // ISO Date string
    scheduled: string | null; // ISO Date string
    goalId: string | null; // ID of the goal this task is linked to
    createdAt: string; // ISO Date string
    completedAt?: string | null; // ISO Date string
};

const DEFAULT_TASKS: Task[] = [
    {
        id: "1",
        title: "Refactor Auth System",
        project: "SelfOS",
        priority: "high",
        status: "pending",
        deadline: new Date(Date.now() + 86400000).toISOString(), // Tomorrow
        scheduled: null,
        goalId: null,
        link: null,
        createdAt: new Date().toISOString(),
    },
    {
        id: "2",
        title: "Write Q4 Goals",
        project: "Life",
        priority: "medium",
        status: "pending",
        deadline: new Date(Date.now() + 172800000).toISOString(), // Day after tomorrow
        scheduled: new Date(Date.now() + 86400000).toISOString(),
        goalId: null,
        link: null,
        createdAt: new Date().toISOString(),
    },
];

// ============================================================================
// Tasks Store
// ============================================================================

class TasksStore {
    store = new LocalStore<Task[]>("selfos_tasks_v2", DEFAULT_TASKS);

    get tasks() {
        return this.store.value;
    }

    /**
     * Adds a single task to the store.
     * @param task - Task details excluding autogenerated fields
     */
    add(task: Omit<Task, "id" | "createdAt" | "status" | "completedAt">) {
        this.store.value.push({
            id: crypto.randomUUID(),
            title: task.title,
            description: task.description,
            link: task.link || null,
            goalId: task.goalId || null,
            project: task.project || "General",
            priority: task.priority || "medium",
            status: "pending",
            deadline: task.deadline || null,
            scheduled: task.scheduled || null,
            createdAt: new Date().toISOString(),
            completedAt: null,
        });
    }

    // Helper functions for parsing
    private isYouTubePlaylistUrl(text: string): boolean {
        return /youtube\.com\/playlist\?list=|youtu\.be\/.*\?list=/.test(text);
    }

    private async parseYouTubePlaylist(url: string): Promise<Array<{ title: string; url: string }>> {
        try {
            const response = await fetch('/api/youtube-playlist', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url })
            });
            if (!response.ok) return [];
            const data = await response.json();
            return data.videos || [];
        } catch (error) {
            console.error('Failed to parse YouTube playlist:', error);
            return [];
        }
    }

    private parseTaskLine(line: string): { title: string; link: string | null } {
        const urlMatch = line.match(/(https?:\/\/[^\s]+)/);
        if (urlMatch) {
            const url = urlMatch[1];
            const title = line.replace(url, '').trim();
            return { title: title || url, link: url };
        }
        return { title: line, link: null };
    }

    /**
     * Adds multiple tasks from a multiline string or YouTube playlist URL.
     * @param input - Multiline string of tasks or YouTube playlist URL
     * @param project - Project to assign the tasks to
     * @param priority - Priority for the tasks
     * @returns Number of tasks added
     */
    async addBatch(input: string, project: string = "General", priority: "low" | "medium" | "high" = "medium") {
        const trimmed = input.trim();

        if (this.isYouTubePlaylistUrl(trimmed)) {
            const videos = await this.parseYouTubePlaylist(trimmed);
            for (const video of videos) {
                this.add({
                    title: video.title,
                    link: video.url,
                    goalId: null,
                    project,
                    priority,
                    deadline: null,
                    scheduled: null
                });
            }
            return videos.length;
        }

        const lines = trimmed
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);

        for (const line of lines) {
            const { title, link } = this.parseTaskLine(line);
            this.add({
                title,
                link,
                goalId: null,
                project,
                priority,
                deadline: null,
                scheduled: null
            });
        }
        return lines.length;
    }

    update(id: string, updates: Partial<Omit<Task, "id" | "createdAt">>) {
        const index = this.store.value.findIndex((t) => t.id === id);
        if (index !== -1) {
            this.store.value[index] = { ...this.store.value[index], ...updates };
        }
    }

    /**
     * Toggles the completion status of a task.
     * @param id - ID of the task to toggle
     */
    async toggle(id: string) {
        const task = this.store.value.find((t) => t.id === id);
        if (task) {
            const wasCompleted = task.status === "completed";

            if (wasCompleted) {
                // Uncomplete task
                task.status = "pending";
                task.completedAt = null;
            } else {
                // Complete task
                task.status = "completed";
                task.completedAt = new Date().toISOString();
            }
        }
    }

    remove(id: string) {
        this.store.value = this.store.value.filter((t) => t.id !== id);
    }

    get activeCount() {
        return this.store.value.filter((t) => t.status !== "completed").length;
    }

    get completedCount() {
        return this.store.value.filter((t) => t.status === "completed").length;
    }
}

export const tasksStore = new TasksStore();
